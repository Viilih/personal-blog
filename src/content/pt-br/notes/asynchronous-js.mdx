---
title: Assincronicidade em JavaScript e o Event Loop
pubDate: 2025-06-24
draft: false
---

# Como Funciona a Assincronicidade em JavaScript

JavaScript √© uma linguagem s√≠ncrona e com uma √∫nica thread de execu√ß√£o ‚Üí Isso significa que o JavaScript roda uma linha de c√≥digo por vez, e s√≥ passa para a pr√≥xima quando terminar a anterior.

Imagina esse trecho de c√≥digo:

```javascript
const num = 3;
function multiplyBy2(inputNumber) {
  const result = inputNumber * 2;
  return result;
}

const output = multiplyBy2(num);
const anotherOutput = multiplyBy2(10);
```

Por exemplo, quando a vari√°vel `output` √© definida, nossa thread de execu√ß√£o vai rodar apenas o c√≥digo do contexto gerado pela chamada da fun√ß√£o `multiplyBy2`. S√≥ depois que essa execu√ß√£o termina, seguimos para a pr√≥xima linha.

**JavaScript √© single-threaded === uma instru√ß√£o por vez**

Mas o que acontece se tivermos uma linha de c√≥digo lenta? E se eu quiser buscar informa√ß√µes de v√°rios reposit√≥rios do GitHub e isso demorar um pouco? Nossa aplica√ß√£o vai ter que esperar isso terminar pra seguir com o restante? Poderia ser... mas isso deixaria a aplica√ß√£o lenta!

At√© agora, com esse modelo de pensamento, temos:

- Thread de execu√ß√£o
- Ambiente de mem√≥ria
- Call stack

Mas isso ainda n√£o d√° conta das novas situa√ß√µes que aparecem por a√≠.

## Al√©m do JavaScript: As Funcionalidades do Navegador

Pra lidar com essas situa√ß√µes, a gente precisa de mais do que s√≥ o JavaScript ‚Äî precisamos de recursos al√©m da linguagem! √â a√≠ que entram esses novos componentes:

- **APIs do Navegador**
- **Promises**
- **Event Loop, Callback Queue e Microtask Queue**

JavaScript normalmente roda dentro do navegador! E √© por isso que conseguimos acessar essas funcionalidades extras por meio de algumas fun√ß√µes.

**Funcionalidades do navegador:**

- Requisi√ß√µes de rede ‚Äì (`fetch`/`xhr`)
- Manipula√ß√£o do DOM ‚Äì (`document`)
- Temporizadores ‚Äì (`setTimeout`)

## Algumas perguntas "simples"

Qual desses logs aparece primeiro?

```javascript
function printHello() {
  console.log("hi from the function");
}
setTimeout(printHello, 1000);
console.log("Hello from the global");

// Resposta: Hello from the global
```

E esse?

```javascript
function printHello() {
  console.log("hi from the function");
}
setTimeout(printHello, 0);
console.log("Hello from the global");

// Resposta: Hello from the global
```

## Event Loop

Vamos mergulhar nesse trecho de c√≥digo pra entender como o JavaScript conversa com as funcionalidades do navegador e como o event loop entra em cena :)

Como j√° comentamos, o JavaScript roda linha por linha. Ent√£o vamos analisar passo a passo, porque acredito que √© a melhor forma de entender o que est√° acontecendo de verdade!

```javascript
function printHello() {
  console.log("Hello");
}

function blockFor1Sec() {
  // Imagina aqui um loop gigante rodando por 1 segundo
}

setTimeout(printHello, 0);

blockFor1Sec();

console.log("Hi outside the function");
```

### Passo a passo

**Primeiro**, declaramos a fun√ß√£o `printHello` ‚Äì nada demais.

**Depois**, declaramos `blockFor1Sec`, que vai bloquear a thread por 1 segundo com algum loop gigantesco.

**Em seguida**, chamamos uma funcionalidade do navegador atrav√©s da fun√ß√£o `setTimeout`. Isso diz pro navegador: "depois de 0 milissegundos, execute a fun√ß√£o `printHello`".

**Detalhe importante:** `setTimeout` n√£o √© uma fun√ß√£o do JavaScript ‚Äì √© uma **Web API** fornecida pelo navegador! Quando o JS encontra o `setTimeout`, ele delega essa tarefa pro navegador e j√° segue pra pr√≥xima linha de c√≥digo.

Mas... a fun√ß√£o `printHello` vai rodar logo depois? **N√ÉO!** A gente vai entender por qu√™ daqui a pouco, mas j√° guarda essa informa√ß√£o üíù

**Depois disso**, chamamos `blockFor1Sec`, que cria um novo contexto de execu√ß√£o e entra na call stack.

Quando `blockFor1Sec` termina, ela sai da call stack. E agora sim vamos executar `printHello`, n√©? **N√ÉO!** Estranho, n√©? Tipo‚Ä¶ era pra acontecer‚Ä¶ mas segura esse pensamento üíù

**A√≠**, temos o `console.log("Hi outside the function")` e **S√ì DEPOIS** vemos o "Hello" da fun√ß√£o `printHello`.

### Alguns questionamentos que voc√™ pode ter

Voc√™ pode estar pensando:

- **Por que `printHello` n√£o foi direto pra call stack depois do `setTimeout`?** Porque `setTimeout` √© uma **Web API**, n√£o faz parte do JavaScript puro! Quando usamos Web APIs (como `setTimeout`, `fetch`, eventos do DOM etc.), o navegador cuida delas separadamente da thread principal do JS. Quando a tarefa termina, o navegador coloca a callback (`printHello`) na **callback queue** ‚Äì e n√£o direto na call stack.

- **Ent√£o quando a gente pode tirar `printHello` da callback queue e jogar na call stack?** S√≥ quando a call stack estiver completamente vazia! O sistema fica o tempo todo perguntando:

  _Tem alguma fun√ß√£o na call stack?_

  - **Sim**: Continuo executando as fun√ß√µes dentro da call stack
  - **N√£o**: Vai at√© a callback queue, pega a pr√≥xima fun√ß√£o e coloca na call stack.

E esse monitoramento constante? √â justamente o trabalho do **event loop**!

## Ent√£o, O Que √â o Event Loop?

O **Event Loop** √© o "controlador de tr√°fego" do JavaScript, coordenando tudo isso:

- **A execu√ß√£o s√≠ncrona do JS** (a call stack)
- **As APIs do navegador** (setTimeout, fetch, eventos do DOM, etc.)
- **A fila de callbacks** (onde as fun√ß√µes ficam esperando a call stack esvaziar)

**O que ele faz:**

1. **Fica de olho** na call stack o tempo todo
2. **Checa** se est√° vazia
3. **Move** a primeira fun√ß√£o da callback queue pra call stack (somente quando estiver vazia)
4. **Repete** esse processo pra sempre

**Por que isso √© importante?** Porque o JavaScript √© single-threaded, mas o navegador n√£o √©! Ele consegue lidar com v√°rias tarefas ao mesmo tempo (timers, requisi√ß√µes de rede etc.) enquanto o JS vai rodando seu c√≥digo. O event loop garante que, quando essas tarefas do navegador terminarem, suas callbacks sejam executadas na hora certa ‚Äì ou seja, quando a thread principal estiver livre.

**Simplificando:** O event loop √© o que permite o JavaScript ser n√£o bloqueante mesmo sendo single-threaded. Ele faz a ponte entre o jeito s√≠ncrono do JavaScript e o mundo ass√≠ncrono das Web APIs.
