---
title: Como implementar um backend com Node?
pubDate: 2025-01-27
---

## IntroduÃ§Ã£o

### O que vocÃª pode esperar deste post?

ApÃ³s ler este post, vocÃª serÃ¡ capaz de desenvolver APIs RESTful usando TypeScript e Express, conectadas a um banco de dados e utilizando o TypeORM como ferramenta ORM.

AlÃ©m disso, vocÃª adquirirÃ¡ conhecimentos para organizar seus projetos, lidar com erros, implementar logs, configurar arquivos de ambiente, variÃ¡veis de ambiente e utilizar o Docker para conteinerizar sua aplicaÃ§Ã£o.

### PrÃ©-requisitos

NÃ£o Ã© uma regra, mas acredito que vocÃª aproveitarÃ¡ melhor este post se tiver conhecimento bÃ¡sico sobre:

- JavaScript / TypeScript
- O que Ã© uma API
- PrincÃ­pios REST

Lembrando que nÃ£o Ã© obrigatÃ³rio! Vou abordar brevemente esses tÃ³picos ao longo do post.

### Por que estou usando Node e Express para isso?

Bem, respondendo de forma simples: pura curiosidade! ðŸ˜„

No momento em que escrevo este post, trabalho com o ecossistema .NET no back-end e com React e TypeScript no front-end. Fiquei curioso para ver como seria trabalhar com TypeScript/JavaScript no back-end tambÃ©m, por isso escolhi essas tecnologias.

Desculpe se vocÃª esperava algo mais "bonito".

## Conceitos fundamentais

### O que sÃ£o NodeJS e Express?

NodeJS Ã© um ambiente de execuÃ§Ã£o JavaScript que permite rodar JavaScript fora do navegador. Ele foi construÃ­do sobre o motor V8 do Chrome, e como o V8 compila diretamente o cÃ³digo JavaScript em cÃ³digo de mÃ¡quina, ele se torna altamente eficiente. VocÃª pode conferir mais sobre isso [aqui](https://www.freecodecamp.org/news/how-javascript-works-behind-the-scenes/) ([documentaÃ§Ã£o](https://nodejs.org/en)).

Express Ã© um framework para construÃ§Ã£o de aplicaÃ§Ãµes web utilizando NodeJS ([documentaÃ§Ã£o](https://expressjs.com/)).

### O que Ã© TypeScript e por que usÃ¡-lo?

TypeScript Ã© um [superconjunto](https://www.epicweb.dev/what-is-a-superset-in-programming) de JavaScript desenvolvido pela Microsoft. Ele adiciona uma camada de tipagem ao JavaScript, permitindo definir tipos para variÃ¡veis, parÃ¢metros e retornos de funÃ§Ãµes.

O uso do TypeScript no desenvolvimento da sua aplicaÃ§Ã£o pode garantir seguranÃ§a de tipos, melhorar a manutenÃ§Ã£o do cÃ³digo e facilitar a detecÃ§Ã£o de erros.

### APIs RESTful

API Ã© a sigla para Application Programming Interface, utilizada para a comunicaÃ§Ã£o entre servidores e serviÃ§os.

Uma API RESTful Ã© uma API que segue os princÃ­pios do [REST](https://restfulapi.net/), que incluem:

- Cacheabilidade
- Stateless (sem estado)
- Uso de URIs
- Uso de verbos HTTP

### O que Ã© um ORM e o que Ã© TypeORM?

ORM (Object-Relational Mapper) Ã© uma ferramenta que ajuda a mapear e traduzir os modelos de banco de dados relacionais para modelos orientados a objetos utilizados em aplicaÃ§Ãµes cliente.

O TypeORM Ã© uma dessas ferramentas, permitindo trabalhar com bancos de dados de forma mais estruturada e orientada a objetos.

## ConfiguraÃ§Ã£o do Projeto

### ConfiguraÃ§Ã£o Inicial

Para iniciar nosso projeto:

```ts
npx typeorm init --name MyProject --database postgres

cd MyProject

npm i express  @types/express --save
```

Eu gosto de deletar o arquivo `src/index.ts` e criar um `server.ts`, mas a escolha Ã© sua.

Com isso, teremos uma estrutura inicial para nossa aplicaÃ§Ã£o, mas me sinto mais confortÃ¡vel adicionando algumas outras pastas e arquivos que abordarei agora. Antes disso, vocÃª precisarÃ¡ dessas dependÃªncias:

```ts
npm i winston
npm i dotenv
```

Antes de configurar nossos arquivos de configuraÃ§Ã£o, ajuste seu `tsconfig.json` para este formato, a fim de evitar problemas de importaÃ§Ã£o com algumas bibliotecas, preparar a build da aplicaÃ§Ã£o e ajudar nos testes:

```json
{
  "compilerOptions": {
    "lib": ["es5", "es6"],
    "target": "ES2016",
    "module": "commonjs",
    "moduleResolution": "node",
    "outDir": "./build",
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "sourceMap": true,
    "esModuleInterop": true,
    "types": ["jest", "reflect-metadata"]
  },
  "exclude": ["node_modules/"],
  "include": ["src/**/*.ts", "test/**/*.ts"]
}
```

Aqui estÃ£o alguns arquivos de configuraÃ§Ã£o onde coloco algumas configuraÃ§Ãµes e o arquivo de logging:

```ts
// src/config/config.ts
import dotenv from "dotenv";

dotenv.config();

// Flags de ambiente
export const ENV = {
  DEVELOPMENT: process.env.NODE_ENV === "development",
  TEST: process.env.NODE_ENV === "test",
};

// ConfiguraÃ§Ã£o do servidor
export const SERVER = {
  HOSTNAME: process.env.SERVER_HOSTNAME || "localhost",
  PORT: process.env.SERVER_PORT ? Number(process.env.SERVER_PORT) : 1337,
};

// ConfiguraÃ§Ã£o do banco de dados
export const DATABASE = {
  HOST: process.env.DB_HOST || "localhost",
  PORT: process.env.DB_PORT ? Number(process.env.DB_PORT) : 5432,
  USERNAME: process.env.DB_USERNAME || "postgres",
  PASSWORD: process.env.DB_PASSWORD || "postgres",
  NAME: process.env.DB_DATABASE || "localdb",
};
```

```ts
// src/config/logger.ts
import winston from "winston";
const { combine, timestamp, printf, colorize } = winston.format;
const logLevels = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  verbose: 4,
  debug: 5,
  silly: 6,
};
const colors = {
  error: "red",
  warn: "yellow",
  info: "green",
};
winston.addColors(colors);
const logger = winston.createLogger({
  levels: logLevels,
  format: combine(
    timestamp({
      format: "YYYY-MM-DD HH:mm:ss",
    }),
    colorize(),
    winston.format.printf(({ level, message, timestamp }) => {
      return `${timestamp} [${level}]: ${message}`;
    }),
  ),
  transports: [new winston.transports.Console()],
});

export default logger;
```

### Por que precisamos desses arquivos?

Por duas principais razÃµes:

1. Ã‰ mais fÃ¡cil definir variÃ¡veis de ambiente e configuraÃ§Ãµes quando vocÃª tem um arquivo centralizado.
2. Ã‰ Ãºtil para acompanhar o que estÃ¡ acontecendo em algum processo da nossa aplicaÃ§Ã£o. Acredite em mim quando digo que logging pode te salvar de MUITO trabalho se for corretamente configurado. Nesta aplicaÃ§Ã£o usaremos [winston](https://github.com/winstonjs/winston).

Nesta aplicaÃ§Ã£o, usaremos essas variÃ¡veis de ambiente para configurar nosso banco de dados.

### Camada de Banco de Dados

### Trabalhando com entidades

Antes de configurar nosso arquivo `data-source.ts`, precisamos criar nossas entidades. Mas vocÃª pode se perguntar: o que sÃ£o essas entidades?

Basicamente, sÃ£o classes que contÃªm a lÃ³gica de negÃ³cio e atributos que usaremos em nossa aplicaÃ§Ã£o e que serÃ£o mapeados para tabelas no banco de dados.

Nesta aplicaÃ§Ã£o, usaremos um livro (Book) como entidade para realizar operaÃ§Ãµes.

Crie uma pasta `entities` e coloque o arquivo `book.ts` dentro dela:

```ts
// src/entities/book.ts
import {
  Column,
  CreateDateColumn,
  Entity,
  PrimaryGeneratedColumn,
} from "typeorm";

@Entity()
export class Book {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: "varchar", length: 50 })
  author: string;

  @Column({ type: "varchar", length: 100 })
  title: string;

  @CreateDateColumn()
  publishedAt: Date;
}
```

Para tornar suas entidades disponÃ­veis para criaÃ§Ã£o no banco de dados, vocÃª precisarÃ¡ usar alguns decoradores oferecidos pelo TypeORM.

Acima estÃ¡ uma implementaÃ§Ã£o simples de um modelo que se torna uma entidade no banco de dados, usando decoradores para chave primÃ¡ria, colunas e data.

Se quiser saber mais sobre isso, consulte a [documentaÃ§Ã£o](https://typeorm.io/).

NÃ£o Ã© obrigatÃ³rio, mas acredito que seja Ãºtil criar uma interface para essa entidade, a fim de lidar com os repositÃ³rios e definir tipos:

```ts
// src/interfaces/IBook.ts
export interface IBook {
  id: number;
  author: string;
  title: string;
  publishedAt: Date;
}
```

### ConfiguraÃ§Ã£o do TypeORM

Para configurar nosso TypeORM, moveremos a configuraÃ§Ã£o para dentro da pasta `database` e manteremos assim:

```ts
// src/database/data-source.ts
import "reflect-metadata";
import { DataSource } from "typeorm";
import { DATABASE } from "../config/config";
import { Book } from "../entities/book";

export const AppDataSource = new DataSource({
  type: "postgres",
  host: DATABASE.HOST,
  port: DATABASE.PORT,
  username: DATABASE.USERNAME,
  password: DATABASE.PASSWORD,
  database: DATABASE.NAME,
  synchronize: true,
  logging: false,
  entities: [Book],
  migrations: [],
  subscribers: [],
});
```

## ImplementaÃ§Ã£o da API

### Organizando controladores e suas rotas

Se vocÃª nÃ£o sabe o que sÃ£o controladores, eles sÃ£o os pontos de entrada para aplicaÃ§Ãµes externas se comunicarem com a nossa. Ã‰ por meio deles e de suas URIs que saberemos qual aÃ§Ã£o ou recurso estÃ¡ sendo solicitado.

Antes de mostrar a implementaÃ§Ã£o do nosso controlador, utilizamos esquemas, que sÃ£o basicamente um modelo que define a estrutura e as regras de validaÃ§Ã£o para os dados:

Estamos usando [joi](https://joi.dev/) para lidar com esses esquemas e validaÃ§Ãµes:

```node
npm i joi
```

Neste caso, criamos um esquema para lidar com algumas operaÃ§Ãµes que faremos:

```ts
// src/schemas/index.ts
import Joi from "joi";

export const bookSchema = {
  idSchema: Joi.object({
    id: Joi.number().integer().positive().required(),
  }),

  createSchema: Joi.object({
    title: Joi.string().required(),
    author: Joi.string().required(),
  }),

  updateSchema: Joi.object({
    title: Joi.string(),
    author: Joi.string(),
  }),
};
```

Agora podemos passar para o nosso controlador:

```ts
// src/controllers/bookController.ts
import { Router, Request, Response, NextFunction } from "express";
import { bookSchema } from "../schemas";
import BookRepository from "../repositories/BookRepository";
import { BookDTO } from "../dtos/book/insert-book-dto";

const baseRoute = "/book";
export const bookRouter = Router();

bookRouter.post(
  `${baseRoute}/insertBook`,
  async (request: Request, response: Response, next: NextFunction) => {
    try {
      const { error } = bookSchema.createSchema.validate(request.body, {
        abortEarly: false,
      });

      if (error) {
        response.status(400).json({
          status: "error",
          message: "Falha na validaÃ§Ã£o",
          errors: error.details.map((err) => err.message),
        });
      }

      const res = await BookRepository.createBook(request.body);
      response
        .status(200)
        .json({ payload: request.body, responseFromRepo: res });
    } catch (error) {
      next(error);
    }
  },
);
```

### DefiniÃ§Ã£o do roteador

Depois de criar nosso controlador, precisamos definir o arquivo de rotas, que centralizarÃ¡ as rotas dos nossos controladores:

```ts
// src/routes/bookRoutes.ts
import { Router } from "express";
import { bookRouter } from "../controllers/bookController";

const routers = Router();

routers.use(bookRouter);

export default routers;
```

### O uso de middlewares

Middlewares sÃ£o funÃ§Ãµes que sÃ£o executadas entre o recebimento de uma requisiÃ§Ã£o e o envio de uma resposta em uma aplicaÃ§Ã£o web.

Na nossa aplicaÃ§Ã£o, temos 4 middlewares:

- **corsHandler**: Lida com o compartilhamento de recursos entre origens diferentes (CORS) definindo cabeÃ§alhos apropriados para permitir requisiÃ§Ãµes de outras origens.
- **errorHandler**: Processa erros, os registra e envia respostas de erro aos clientes.
- **loggingHandler**: Registra informaÃ§Ãµes sobre requisiÃ§Ãµes recebidas e seus resultados.
- **routeNotFound**: Lida com casos em que a rota solicitada nÃ£o existe (erros 404).

### ConfiguraÃ§Ã£o do servidor

Para implementar todas as configuraÃ§Ãµes que preparamos, temos nosso arquivo `server.ts`, responsÃ¡vel por iniciar nosso servidor:

```ts
// src/server.ts
import http from "http";
import express from "express";
import logger from "./config/logger";
import { loggingHandler } from "./middleware/loggingHandler";
import { corsHandler } from "./middleware/corsHandler";
import { routeNotFound } from "./middleware/routeNotFound";
import { SERVER } from "./config/config";
import { AppDataSource } from "./database/data-source";
import routers from "./routes/bookRoutes";
import { errorHandler } from "./middleware/errorHandler";

export const application = express();
export let httpServer: ReturnType<typeof http.createServer>;

export const Main = async () => {
  logger.info("-----------------------");
  logger.info("Inicializando API");
  logger.info("-----------------------");

  application.use(express.urlencoded({ extended: true }));
  application.use(express.json());

  application.use(loggingHandler);
  application.use(corsHandler);

  application.use(routers);
  application.use(routeNotFound);
  application.use(errorHandler);

  httpServer = http.createServer(application);

  httpServer.listen(SERVER.PORT, SERVER.HOSTNAME, () => {
    logger.info(`Servidor rodando em http://${SERVER.HOSTNAME}:${SERVER.PORT}`);
  });

  await AppDataSource.initialize();
  logger.info("Banco de dados conectado!");
};

if (require.main === module) {
  Main().catch((error) => {
    logger.error("Falha ao iniciar o servidor:", error);
  });
}
```

Depois de configurar o `server.ts`, vocÃª precisa alterar o arquivo de inicializaÃ§Ã£o no `package.json`, mudando de `src/index.ts` para `src/server.ts`, na seÃ§Ã£o de scripts:

```json
"scripts": {
  "start": "ts-node src/server.ts",
  "typeorm": "typeorm-ts-node-commonjs"
}
```

Quando terminar todas essas configuraÃ§Ãµes, vocÃª estarÃ¡ pronto para iniciar sua aplicaÃ§Ã£o e testar seus endpoints!

Para iniciar a aplicaÃ§Ã£o, basta digitar:

```ts
npm start
```

## Testes

Por que testar uma aplicaÃ§Ã£o simples, vocÃª pode perguntar? Bem, eu acredito que comeÃ§ar a escrever testes pode ajudar vocÃª a prevenir bugs em sua aplicaÃ§Ã£o, reduzir tarefas manuais/testar endpoints e tambÃ©m melhorar seu cÃ³digo para tornÃ¡-lo mais fÃ¡cil de testar.

Para esta aplicaÃ§Ã£o, vamos escrever testes de integraÃ§Ã£o, que basicamente testam uma funcionalidade que se comunica entre diferentes partes da nossa aplicaÃ§Ã£o, no nosso caso, nossas camadas (repositÃ³rios, banco de dados, controladores). Se vocÃª quiser saber mais sobre testes, pode verificar este [artigo](https://kentcdodds.com/blog/write-tests).

No nosso caso, vocÃª precisarÃ¡ instalar algumas dependÃªncias:

```ts
npm install --save-dev @types/jest @types/supertest jest supertest ts-jest
```

VocÃª tambÃ©m adicionarÃ¡ o comando "test" no package.json:

```json
"scripts": {
	"start": "ts-node src/server.ts",
	"typeorm": "typeorm-ts-node-commonjs",
	"test": "jest --config jest.config.ts --coverage",
	"build": "rm -rf build/ && tsc"
},
```

E adicionar o tipo jest no seu tsconfig.json:

```json
{
  "compilerOptions": {
    "lib": ["es5", "es6"],
    "target": "ES2016",
    "module": "commonjs",
    "moduleResolution": "node",
    "outDir": "./build",
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "sourceMap": true,
    "esModuleInterop": true,
    "types": ["jest", "reflect-metadata"]
  },
  "exclude": ["node_modules/"],
  "include": ["src/**/*.ts", "test/**/*.ts"]
}
```

Depois disso, vocÃª precisa criar um jest.config.ts na raiz do seu projeto, assim:

```ts
import type { Config } from "jest";

const config: Config = {
  preset: "ts-jest",
  testEnvironment: "node",
  roots: ["<rootDir>/test"],
  maxWorkers: 1,
  detectOpenHandles: true,
};

export default config;
```

ApÃ³s toda essa configuraÃ§Ã£o, podemos criar nossa pasta de teste e comeÃ§ar a escrever testes:

```ts
// test/integration/server.test.ts
import request from "supertest";
import { application, Main, Shutdown } from "../../src/server";

describe("Application", () => {
  beforeAll(async () => {
    await Main();
  });

  afterAll(async () => {
    await Shutdown();
  });

  it("Starts and has the proper test environment", async () => {
    expect(process.env.NODE_ENV).toBe("test");
    expect(application).toBeDefined();
  });

  it("Check our healthcheck route", async () => {
    const response = await request(application).get("/main/healthcheck");
    expect(response.status).toBe(200);
  });

  it("Returns 404 when the route requested is not found.", async () => {
    const response = await request(application).get(
      "/a/cute/route/that/does/not/exist/",
    );
    expect(response.status).toBe(404);
  });
});
```

## ConclusÃ£o

### O que vocÃª aprendeu?

Abordamos conceitos fundamentais do desenvolvimento de uma API RESTful com Node.js usando TypeScript.

VocÃª aprendeu sobre ORMs, sua usabilidade e como eles podem ser aplicados ao seu fluxo de trabalho de desenvolvimento.

TambÃ©m discutimos a importÃ¢ncia dos testes em uma aplicaÃ§Ã£o e como escrevÃª-los com jest.

### Quais sÃ£o os prÃ³ximos passos?

Um Ã³timo prÃ³ximo passo seria desenvolver sua prÃ³pria API para resolver um problema do mundo real ou explorar um contexto de negÃ³cios diferente. Por exemplo, vocÃª poderia construir um sistema de gerenciamento de produtos para uma loja local, um gerenciador de tarefas para produtividade pessoal ou um sistema de rastreamento de inventÃ¡rio para uma pequena empresa.

O importante Ã© escolher um projeto que desafie vocÃª a aplicar o que aprendeu enquanto se alinha com seus interesses!
